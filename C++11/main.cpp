//// Created by matrix on 2022/6/15.//#include <iostream>#include <typeinfo>#include <cxxabi.h>using namespace std;const char* FormatType(const char* t){    return abi::__cxa_demangle(t, nullptr, nullptr, nullptr);}void TAuto(){    auto a = 100;    std::cout << "type of a is " << FormatType(typeid(a).name()) << std::endl;}void TDecltype(){    const int& i = 1;    decltype(i) b = 2; //b是const int& 类型}//移动语义void TMove(){    class A {    public:        explicit A(int size) : size_(size) {            data_ = new int[size];        }        A()= default;        A(const A& a) {            size_ = a.size_;            data_ = new int[size_];            cout << "copy " << endl;        }        A(A&& a)  noexcept {//移动构造函数            this->data_ = a.data_;            a.data_ = nullptr;            cout << "move " << endl;        }        ~A() {            delete[] data_;        }        int *data_{};        int size_{};    };    A a(10);    A b = a;    A c = std::move(a); // 调用移动构造函数}void PrintV(int &t) {    cout << "lvalue" << endl;}void PrintV(int &&t) {    cout << "rvalue" << endl;}template<typename T>void Test(T &&t) {    PrintV(t);    PrintV(std::forward<T>(t));    PrintV(std::move(t));}void TForward(){    Test(1); // lvalue rvalue rvalue    int a = 1;    Test(a); // lvalue lvalue rvalue    Test(std::forward<int>(a)); // lvalue rvalue rvalue 转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值    Test(std::forward<int&>(a)); // lvalue lvalue rvalue 同上    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue 同上}void TLValue(){    //int &a = 1;//错误，左值引用必须绑定一个左值，1是右值    int a = 1;    int &b = a;//正确}void TRValue(){    int a = 0;    int &b = a;    int &&c = 1;    PrintV(a);//lvalue    PrintV(b);//lvalue    PrintV(c);//lvalue    PrintV(std::move(a));//rvalue}int main(int argc, char** argv){    std::cout << "Hello C++11!" << std::endl;    //TAuto();    //TDecltype();    //TMove();    //TForward();    TRValue();    return 0;}